package deploy

import (
	"context"
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/guras256/keenetic-split-tunnel/internal/config"
	"github.com/guras256/keenetic-split-tunnel/internal/platform"
)

// Dependency describes a required system package/binary.
type Dependency struct {
	Name    string // human-readable name
	Binary  string // binary to check in PATH
	Package string // opkg package name
}

// commonDeps lists packages required in all modes.
var commonDeps = []Dependency{
	{Name: "ipset", Binary: "ipset", Package: "ipset"},
	{Name: "iptables", Binary: "iptables", Package: "iptables"},
	{Name: "dnsmasq", Binary: "dnsmasq", Package: "dnsmasq-full"},
	{Name: "dnscrypt-proxy", Binary: "dnscrypt-proxy", Package: "dnscrypt-proxy2"},
}

// modeDeps lists mode-specific packages.
var modeDeps = map[string]Dependency{
	"shadowsocks": {Name: "ss-redir", Binary: "ss-redir", Package: "shadowsocks-libev-ss-redir"},
	"xray":        {Name: "xray", Binary: "xray", Package: "xray"},
}

// CheckResult holds the result of a dependency check.
type CheckResult struct {
	Dep       Dependency
	Installed bool
}

// CheckDependencies verifies that required binaries are available for the given mode.
// mode should be "shadowsocks" or "xray"; defaults to "shadowsocks".
func CheckDependencies(mode string) []CheckResult {
	deps := append([]Dependency(nil), commonDeps...)
	if d, ok := modeDeps[mode]; ok {
		deps = append(deps, d)
	} else {
		deps = append(deps, modeDeps["shadowsocks"])
	}

	var missing []CheckResult
	for _, dep := range deps {
		if !binaryExists(dep.Binary) {
			missing = append(missing, CheckResult{Dep: dep, Installed: false})
		}
	}
	return missing
}

func binaryExists(name string) bool {
	_, err := lookPath(name)
	return err == nil
}

func lookPath(name string) (string, error) {
	// Check common Entware paths explicitly since PATH might not include them.
	for _, dir := range []string{"/opt/bin", "/opt/sbin", "/opt/usr/bin", "/opt/usr/sbin", "/usr/bin", "/usr/sbin", "/bin", "/sbin"} {
		p := filepath.Join(dir, name)
		if fi, err := os.Stat(p); err == nil && !fi.IsDir() {
			return p, nil
		}
	}
	return "", fmt.Errorf("%s not found", name)
}

// ssRedirConfig is the JSON format expected by ss-redir.
type ssRedirConfig struct {
	Server       string `json:"server"`
	ServerPort   int    `json:"server_port"`
	LocalPort    int    `json:"local_port"`
	Password     string `json:"password"`
	Method       string `json:"method"`
	Timeout      int    `json:"timeout"`
	LocalAddress string `json:"local_address"`
	FastOpen     bool   `json:"fast_open"`
}

// WriteShadowsocksConfig generates /opt/etc/shadowsocks.json from KST config.
func WriteShadowsocksConfig(cfg *config.Config) error {
	sc := ssRedirConfig{
		Server:       cfg.Shadowsocks.Server,
		ServerPort:   cfg.Shadowsocks.ServerPort,
		LocalPort:    cfg.Shadowsocks.LocalPort,
		Password:     cfg.Shadowsocks.Password,
		Method:       cfg.Shadowsocks.Method,
		Timeout:      86400,
		LocalAddress: "::",
		FastOpen:     false,
	}

	data, err := json.MarshalIndent(sc, "", "  ")
	if err != nil {
		return fmt.Errorf("marshal shadowsocks config: %w", err)
	}

	if err := os.MkdirAll(filepath.Dir(platform.ShadowsocksConfig), 0o755); err != nil {
		return err
	}
	return os.WriteFile(platform.ShadowsocksConfig, append(data, '\n'), 0o600)
}

// WriteDnsmasqConf writes a working dnsmasq.conf for KST.
// DNS queries are always forwarded to dnscrypt-proxy for encrypted resolution.
func WriteDnsmasqConf(cfg *config.Config) error {
	upstream := fmt.Sprintf("127.0.0.1#%d", cfg.DNSCrypt.Port)

	iface := cfg.Network.EntwareInterface
	if iface == "" {
		iface = "br0"
	}

	var b strings.Builder
	b.WriteString("# Generated by KST. Do not edit manually.\n")
	b.WriteString("user=nobody\n")
	b.WriteString(fmt.Sprintf("pid-file=%s\n", platform.DnsmasqPidFile))
	b.WriteString(fmt.Sprintf("interface=%s\n", iface))
	b.WriteString("listen-address=127.0.0.1\n")
	b.WriteString("port=53\n")
	b.WriteString("min-port=4096\n")
	if cfg.DNS.CacheEnabled {
		b.WriteString(fmt.Sprintf("cache-size=%d\n", cfg.DNS.CacheSize))
	} else {
		b.WriteString("cache-size=0\n")
	}
	b.WriteString("bogus-priv\n")
	b.WriteString("no-negcache\n")
	b.WriteString("no-resolv\n")
	b.WriteString("no-poll\n")
	b.WriteString("clear-on-reload\n")
	b.WriteString("expand-hosts\n")
	b.WriteString("localise-queries\n")
	b.WriteString("domain-needed\n")
	b.WriteString("log-async\n")
	b.WriteString("rebind-localhost-ok\n")
	b.WriteString(fmt.Sprintf("server=%s\n", upstream))
	b.WriteString(fmt.Sprintf("conf-dir=%s/,*.dnsmasq\n", platform.DnsmasqDir))

	if err := os.MkdirAll(filepath.Dir(platform.DnsmasqConfFile), 0o755); err != nil {
		return err
	}
	return os.WriteFile(platform.DnsmasqConfFile, []byte(b.String()), 0o644)
}

// ndmHook maps a source script path to its destination under /opt/etc/ndm/.
type ndmHook struct {
	subdir string // e.g., "fs.d"
	name   string // e.g., "100-ipset"
}

var ndmHooks = []ndmHook{
	{"fs.d", "100-ipset"},
	{"netfilter.d", "100-proxy-redirect"},
	{"netfilter.d", "100-dns-local"},
	{"ifstatechanged.d", "100-unblock"},
	{"ifcreated.d", "kst-iface-add"},
	{"ifdestroyed.d", "kst-iface-del"},
	{"wan.d", "internet-up"},
}

// InstallNDMHooks copies NDM hook scripts to /opt/etc/ndm/.
// It reads scripts from the embedded locations (installed by IPK at /opt/etc/kst/ndm/)
// or falls back to generating minimal scripts.
func InstallNDMHooks() (int, error) {
	installed := 0
	for _, h := range ndmHooks {
		destDir := filepath.Join(platform.NDMDir, h.subdir)
		if err := os.MkdirAll(destDir, 0o755); err != nil {
			return installed, fmt.Errorf("create %s: %w", destDir, err)
		}

		dest := filepath.Join(destDir, h.name)

		// Try to copy from the IPK-installed source first.
		src := filepath.Join(platform.ConfigDir, "ndm", h.subdir, h.name)
		if data, err := os.ReadFile(src); err == nil {
			if err := os.WriteFile(dest, data, 0o755); err != nil {
				return installed, fmt.Errorf("write %s: %w", dest, err)
			}
			installed++
			continue
		}

		// Generate a minimal hook script.
		script := fmt.Sprintf("#!/bin/sh\n[ -x %s ] && %s hook %s \"$@\"\n",
			platform.BinaryPath, platform.BinaryPath, hookEvent(h))
		if err := os.WriteFile(dest, []byte(script), 0o755); err != nil {
			return installed, fmt.Errorf("write %s: %w", dest, err)
		}
		installed++
	}
	return installed, nil
}

// InstallInitScript installs the init.d startup script.
// Always generated from code â€” never copied from IPK files to avoid stale scripts.
// Uses PID file check instead of rc.func's pidof, so that calling "S96kst start"
// while any other kst CLI command is running does not falsely report "already running".
func InstallInitScript() error {
	script := fmt.Sprintf(`#!/bin/sh
PIDFILE=%s
BINARY=%s
PATH=/opt/sbin:/opt/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin

is_running() {
    [ -f "$PIDFILE" ] && kill -0 "$(cat "$PIDFILE")" 2>/dev/null
}

case "$1" in
    start)
        if is_running; then
            echo "kst daemon already running (pid $(cat $PIDFILE))"
            exit 0
        fi
        start-stop-daemon -S -b -m -p "$PIDFILE" -a "$BINARY" -- daemon
        echo "kst daemon started"
        ;;
    stop)
        if is_running; then
            kill "$(cat "$PIDFILE")" 2>/dev/null
            rm -f "$PIDFILE"
            echo "kst daemon stopped"
        else
            echo "kst daemon not running"
        fi
        ;;
    restart)
        $0 stop
        sleep 1
        $0 start
        ;;
    status)
        if is_running; then
            echo "kst daemon running (pid $(cat $PIDFILE))"
        else
            echo "kst daemon stopped"
        fi
        ;;
    *)
        echo "Usage: $0 {start|stop|restart|status}"
        exit 1
        ;;
esac
`, platform.PidFile, platform.BinaryPath)
	return os.WriteFile(platform.InitScript, []byte(script), 0o755)
}

// InstallSSRedirInitScript generates an init.d script for ss-redir.
// The Entware package shadowsocks-libev-ss-redir only ships the binary,
// so we need to create the init script ourselves.
func InstallSSRedirInitScript() error {
	script := fmt.Sprintf(`#!/bin/sh
ENABLED=yes
PROCS=ss-redir
ARGS="-c %s"
PREARGS=""
DESC=$PROCS
PATH=/opt/sbin:/opt/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin

. /opt/etc/init.d/rc.func
`, platform.ShadowsocksConfig)

	if err := os.MkdirAll(filepath.Dir(platform.SSRedirInitScript), 0o755); err != nil {
		return err
	}
	return os.WriteFile(platform.SSRedirInitScript, []byte(script), 0o755)
}

// ValidateXrayConfig does a basic sanity check on the Xray settings.
func ValidateXrayConfig(cfg *config.Config) error {
	if cfg.Xray.Server == "" {
		return fmt.Errorf("xray server address is not configured")
	}
	if cfg.Xray.ServerPort == 0 {
		return fmt.Errorf("xray server port is not configured")
	}
	if cfg.Xray.UUID == "" {
		return fmt.Errorf("xray UUID is not configured")
	}
	if cfg.Xray.PublicKey == "" {
		return fmt.Errorf("xray public key is not configured")
	}
	return nil
}

// ValidateShadowsocksConfig does a basic sanity check on the SS settings.
func ValidateShadowsocksConfig(cfg *config.Config) error {
	if cfg.Shadowsocks.Server == "" {
		return fmt.Errorf("shadowsocks server address is not configured")
	}
	if cfg.Shadowsocks.ServerPort == 0 {
		return fmt.Errorf("shadowsocks server port is not configured")
	}
	if cfg.Shadowsocks.Password == "" {
		return fmt.Errorf("shadowsocks password is not configured")
	}
	return nil
}

// EnsureDirectories creates all required directories.
func EnsureDirectories() error {
	dirs := []string{
		platform.ConfigDir,
		platform.DnsmasqDir,
	}
	for _, d := range dirs {
		if err := os.MkdirAll(d, 0o755); err != nil {
			return fmt.Errorf("create %s: %w", d, err)
		}
	}
	return nil
}

// InstallOpkgDeps attempts to install missing packages via opkg.
func InstallOpkgDeps(ctx context.Context, packages []string) error {
	args := append([]string{"install"}, packages...)
	return platform.RunSilent(ctx, "opkg", args...)
}

// xrayInbound is the dokodemo-door inbound for transparent proxying.
type xrayInbound struct {
	Listen   string          `json:"listen"`
	Port     int             `json:"port"`
	Protocol string          `json:"protocol"`
	Settings xrayDokodemo    `json:"settings"`
	Sniffing xraySniffing    `json:"sniffing"`
}

type xrayDokodemo struct {
	Network        string `json:"network"`
	FollowRedirect bool   `json:"followRedirect"`
}

type xraySniffing struct {
	Enabled     bool     `json:"enabled"`
	DestOverride []string `json:"destOverride"`
}

type xrayOutbound struct {
	Protocol       string              `json:"protocol"`
	Settings       *xrayVlessSettings  `json:"settings,omitempty"`
	StreamSettings *xrayStreamSettings `json:"streamSettings,omitempty"`
	Tag            string              `json:"tag"`
}

type xrayVlessSettings struct {
	Vnext []xrayVnext `json:"vnext"`
}

type xrayVnext struct {
	Address string      `json:"address"`
	Port    int         `json:"port"`
	Users   []xrayUser  `json:"users"`
}

type xrayUser struct {
	ID         string `json:"id"`
	Flow       string `json:"flow,omitempty"`
	Encryption string `json:"encryption"`
}

type xrayStreamSettings struct {
	Network         string            `json:"network"`
	Security        string            `json:"security"`
	RealitySettings xrayRealityConfig `json:"realitySettings"`
}

type xrayRealityConfig struct {
	Show        bool     `json:"show"`
	ServerName  string   `json:"serverName"`
	Fingerprint string   `json:"fingerprint"`
	PublicKey   string   `json:"publicKey"`
	ShortID     string   `json:"shortId"`
	SpiderX     string   `json:"spiderX"`
}

type xrayConfig struct {
	Log      xrayLog        `json:"log"`
	Inbounds []xrayInbound  `json:"inbounds"`
	Outbounds []xrayOutbound `json:"outbounds"`
}

type xrayLog struct {
	LogLevel string `json:"loglevel"`
}

// WriteXrayConfig generates /opt/etc/xray/config.json from KST config.
func WriteXrayConfig(cfg *config.Config) error {
	xc := xrayConfig{
		Log: xrayLog{LogLevel: "warning"},
		Inbounds: []xrayInbound{
			{
				Listen:   "0.0.0.0",
				Port:     cfg.Xray.LocalPort,
				Protocol: "dokodemo-door",
				Settings: xrayDokodemo{
					Network:        "tcp",
					FollowRedirect: true,
				},
				Sniffing: xraySniffing{
					Enabled:     true,
					DestOverride: []string{"http", "tls"},
				},
			},
		},
		Outbounds: []xrayOutbound{
			{
				Protocol: "vless",
				Settings: &xrayVlessSettings{
					Vnext: []xrayVnext{
						{
							Address: cfg.Xray.Server,
							Port:    cfg.Xray.ServerPort,
							Users: []xrayUser{
								{
									ID:         cfg.Xray.UUID,
									Flow:       cfg.Xray.Flow,
									Encryption: "none",
								},
							},
						},
					},
				},
				StreamSettings: &xrayStreamSettings{
					Network:  "tcp",
					Security: "reality",
					RealitySettings: xrayRealityConfig{
						Show:        false,
						ServerName:  cfg.Xray.SNI,
						Fingerprint: cfg.Xray.Fingerprint,
						PublicKey:   cfg.Xray.PublicKey,
						ShortID:     cfg.Xray.ShortID,
						SpiderX:     "/",
					},
				},
				Tag: "proxy",
			},
			{
				Protocol: "freedom",
				Tag:      "direct",
			},
		},
	}

	data, err := json.MarshalIndent(xc, "", "  ")
	if err != nil {
		return fmt.Errorf("marshal xray config: %w", err)
	}

	if err := os.MkdirAll(platform.XrayConfigDir, 0o755); err != nil {
		return err
	}
	return os.WriteFile(platform.XrayConfigFile, append(data, '\n'), 0o600)
}

// InstallXrayInitScript generates an init.d script for xray.
func InstallXrayInitScript() error {
	script := fmt.Sprintf(`#!/bin/sh
ENABLED=yes
PROCS=xray
ARGS="-c %s"
PREARGS=""
DESC=$PROCS
PATH=/opt/sbin:/opt/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin

. /opt/etc/init.d/rc.func
`, platform.XrayConfigFile)

	if err := os.MkdirAll(filepath.Dir(platform.XrayInitScript), 0o755); err != nil {
		return err
	}
	return os.WriteFile(platform.XrayInitScript, []byte(script), 0o755)
}

// UninstallNDMHooks removes all NDM hook scripts installed by KST.
func UninstallNDMHooks() {
	for _, h := range ndmHooks {
		dest := filepath.Join(platform.NDMDir, h.subdir, h.name)
		os.Remove(dest)
	}
}

func hookEvent(h ndmHook) string {
	switch h.subdir {
	case "fs.d":
		return "fs"
	case "netfilter.d":
		return "netfilter"
	case "ifstatechanged.d":
		return "ifstate"
	case "ifcreated.d":
		return "ifcreated"
	case "ifdestroyed.d":
		return "ifdestroyed"
	case "wan.d":
		return "wan"
	default:
		return h.subdir
	}
}
