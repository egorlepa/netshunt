package deploy

import (
	"context"
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/guras256/keenetic-split-tunnel/internal/config"
	"github.com/guras256/keenetic-split-tunnel/internal/platform"
)

// Dependency describes a required system package/binary.
type Dependency struct {
	Name    string // human-readable name
	Binary  string // binary to check in PATH
	Package string // opkg package name
}

// RequiredDeps lists packages that must be installed for KST to work.
var RequiredDeps = []Dependency{
	{Name: "ipset", Binary: "ipset", Package: "ipset"},
	{Name: "iptables", Binary: "iptables", Package: "iptables"},
	{Name: "dnsmasq", Binary: "dnsmasq", Package: "dnsmasq-full"},
	{Name: "ss-redir", Binary: "ss-redir", Package: "shadowsocks-libev-ss-redir"},
	{Name: "dnscrypt-proxy", Binary: "dnscrypt-proxy", Package: "dnscrypt-proxy2"},
}

// CheckResult holds the result of a dependency check.
type CheckResult struct {
	Dep       Dependency
	Installed bool
}

// CheckDependencies verifies that required binaries are available.
func CheckDependencies() []CheckResult {
	var missing []CheckResult
	for _, dep := range RequiredDeps {
		if !binaryExists(dep.Binary) {
			missing = append(missing, CheckResult{Dep: dep, Installed: false})
		}
	}
	return missing
}

func binaryExists(name string) bool {
	_, err := lookPath(name)
	return err == nil
}

func lookPath(name string) (string, error) {
	// Check common Entware paths explicitly since PATH might not include them.
	for _, dir := range []string{"/opt/bin", "/opt/sbin", "/opt/usr/bin", "/opt/usr/sbin", "/usr/bin", "/usr/sbin", "/bin", "/sbin"} {
		p := filepath.Join(dir, name)
		if fi, err := os.Stat(p); err == nil && !fi.IsDir() {
			return p, nil
		}
	}
	return "", fmt.Errorf("%s not found", name)
}

// ssRedirConfig is the JSON format expected by ss-redir.
type ssRedirConfig struct {
	Server       string `json:"server"`
	ServerPort   int    `json:"server_port"`
	LocalPort    int    `json:"local_port"`
	Password     string `json:"password"`
	Method       string `json:"method"`
	Timeout      int    `json:"timeout"`
	LocalAddress string `json:"local_address"`
	FastOpen     bool   `json:"fast_open"`
}

// WriteShadowsocksConfig generates /opt/etc/shadowsocks.json from KST config.
func WriteShadowsocksConfig(cfg *config.Config) error {
	sc := ssRedirConfig{
		Server:       cfg.Shadowsocks.Server,
		ServerPort:   cfg.Shadowsocks.ServerPort,
		LocalPort:    cfg.Shadowsocks.LocalPort,
		Password:     cfg.Shadowsocks.Password,
		Method:       cfg.Shadowsocks.Method,
		Timeout:      86400,
		LocalAddress: "::",
		FastOpen:     false,
	}

	data, err := json.MarshalIndent(sc, "", "  ")
	if err != nil {
		return fmt.Errorf("marshal shadowsocks config: %w", err)
	}

	if err := os.MkdirAll(filepath.Dir(platform.ShadowsocksConfig), 0o755); err != nil {
		return err
	}
	return os.WriteFile(platform.ShadowsocksConfig, append(data, '\n'), 0o600)
}

// WriteDnsmasqConf writes a working dnsmasq.conf for KST.
// DNS queries are always forwarded to dnscrypt-proxy for encrypted resolution.
func WriteDnsmasqConf(cfg *config.Config) error {
	upstream := fmt.Sprintf("127.0.0.1#%d", cfg.DNSCrypt.Port)

	iface := cfg.Network.EntwareInterface
	if iface == "" {
		iface = "br0"
	}

	var b strings.Builder
	b.WriteString("# Generated by KST. Do not edit manually.\n")
	b.WriteString("user=nobody\n")
	b.WriteString(fmt.Sprintf("pid-file=%s\n", platform.DnsmasqPidFile))
	b.WriteString(fmt.Sprintf("interface=%s\n", iface))
	b.WriteString("listen-address=127.0.0.1\n")
	b.WriteString("port=53\n")
	b.WriteString("min-port=4096\n")
	if cfg.DNS.CacheEnabled {
		b.WriteString(fmt.Sprintf("cache-size=%d\n", cfg.DNS.CacheSize))
	} else {
		b.WriteString("cache-size=0\n")
	}
	b.WriteString("bogus-priv\n")
	b.WriteString("no-negcache\n")
	b.WriteString("no-resolv\n")
	b.WriteString("no-poll\n")
	b.WriteString("clear-on-reload\n")
	b.WriteString("expand-hosts\n")
	b.WriteString("localise-queries\n")
	b.WriteString("domain-needed\n")
	b.WriteString("log-async\n")
	b.WriteString("rebind-localhost-ok\n")
	b.WriteString(fmt.Sprintf("server=%s\n", upstream))
	b.WriteString(fmt.Sprintf("conf-dir=%s/,*.dnsmasq\n", platform.DnsmasqDir))

	if err := os.MkdirAll(filepath.Dir(platform.DnsmasqConfFile), 0o755); err != nil {
		return err
	}
	return os.WriteFile(platform.DnsmasqConfFile, []byte(b.String()), 0o644)
}

// ndmHook maps a source script path to its destination under /opt/etc/ndm/.
type ndmHook struct {
	subdir string // e.g., "fs.d"
	name   string // e.g., "100-ipset"
}

var ndmHooks = []ndmHook{
	{"fs.d", "100-ipset"},
	{"netfilter.d", "100-proxy-redirect"},
	{"netfilter.d", "100-dns-local"},
	{"ifstatechanged.d", "100-unblock"},
	{"ifcreated.d", "kst-iface-add"},
	{"ifdestroyed.d", "kst-iface-del"},
	{"wan.d", "internet-up"},
}

// InstallNDMHooks copies NDM hook scripts to /opt/etc/ndm/.
// It reads scripts from the embedded locations (installed by IPK at /opt/etc/kst/ndm/)
// or falls back to generating minimal scripts.
func InstallNDMHooks() (int, error) {
	installed := 0
	for _, h := range ndmHooks {
		destDir := filepath.Join(platform.NDMDir, h.subdir)
		if err := os.MkdirAll(destDir, 0o755); err != nil {
			return installed, fmt.Errorf("create %s: %w", destDir, err)
		}

		dest := filepath.Join(destDir, h.name)

		// Try to copy from the IPK-installed source first.
		src := filepath.Join(platform.ConfigDir, "ndm", h.subdir, h.name)
		if data, err := os.ReadFile(src); err == nil {
			if err := os.WriteFile(dest, data, 0o755); err != nil {
				return installed, fmt.Errorf("write %s: %w", dest, err)
			}
			installed++
			continue
		}

		// Generate a minimal hook script.
		script := fmt.Sprintf("#!/bin/sh\n[ -x %s ] && %s hook %s \"$@\"\n",
			platform.BinaryPath, platform.BinaryPath, hookEvent(h))
		if err := os.WriteFile(dest, []byte(script), 0o755); err != nil {
			return installed, fmt.Errorf("write %s: %w", dest, err)
		}
		installed++
	}
	return installed, nil
}

// InstallInitScript installs the init.d startup script.
func InstallInitScript() error {
	src := filepath.Join(platform.ConfigDir, "init.d", "S96kst")
	if data, err := os.ReadFile(src); err == nil {
		return os.WriteFile(platform.InitScript, data, 0o755)
	}

	// Generate a minimal init script.
	script := `#!/bin/sh
ENABLED=yes
PROCS=kst
ARGS="daemon"
PREARGS=""
DESC=$PROCS
PATH=/opt/sbin:/opt/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin

. /opt/etc/init.d/rc.func
`
	return os.WriteFile(platform.InitScript, []byte(script), 0o755)
}

// InstallSSRedirInitScript generates an init.d script for ss-redir.
// The Entware package shadowsocks-libev-ss-redir only ships the binary,
// so we need to create the init script ourselves.
func InstallSSRedirInitScript() error {
	script := fmt.Sprintf(`#!/bin/sh
ENABLED=yes
PROCS=ss-redir
ARGS="-c %s"
PREARGS=""
DESC=$PROCS
PATH=/opt/sbin:/opt/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin

. /opt/etc/init.d/rc.func
`, platform.ShadowsocksConfig)

	if err := os.MkdirAll(filepath.Dir(platform.SSRedirInitScript), 0o755); err != nil {
		return err
	}
	return os.WriteFile(platform.SSRedirInitScript, []byte(script), 0o755)
}

// ValidateShadowsocksConfig does a basic sanity check on the SS settings.
func ValidateShadowsocksConfig(cfg *config.Config) error {
	if cfg.Shadowsocks.Server == "" {
		return fmt.Errorf("shadowsocks server address is not configured")
	}
	if cfg.Shadowsocks.ServerPort == 0 {
		return fmt.Errorf("shadowsocks server port is not configured")
	}
	if cfg.Shadowsocks.Password == "" {
		return fmt.Errorf("shadowsocks password is not configured")
	}
	return nil
}

// EnsureDirectories creates all required directories.
func EnsureDirectories() error {
	dirs := []string{
		platform.ConfigDir,
		platform.DnsmasqDir,
	}
	for _, d := range dirs {
		if err := os.MkdirAll(d, 0o755); err != nil {
			return fmt.Errorf("create %s: %w", d, err)
		}
	}
	return nil
}

// InstallOpkgDeps attempts to install missing packages via opkg.
func InstallOpkgDeps(ctx context.Context, packages []string) error {
	args := append([]string{"install"}, packages...)
	return platform.RunSilent(ctx, "opkg", args...)
}

// UninstallNDMHooks removes all NDM hook scripts installed by KST.
func UninstallNDMHooks() {
	for _, h := range ndmHooks {
		dest := filepath.Join(platform.NDMDir, h.subdir, h.name)
		os.Remove(dest)
	}
}

func hookEvent(h ndmHook) string {
	switch h.subdir {
	case "fs.d":
		return "fs"
	case "netfilter.d":
		return "netfilter"
	case "ifstatechanged.d":
		return "ifstate"
	case "ifcreated.d":
		return "ifcreated"
	case "ifdestroyed.d":
		return "ifdestroyed"
	case "wan.d":
		return "wan"
	default:
		return h.subdir
	}
}
